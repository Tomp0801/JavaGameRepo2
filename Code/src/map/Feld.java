package map;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

/**
 * Ein Feld eines gewissen typs, das bebaut werden kann und/oder Objekte enthalten kann
 * 
 * @author Thomas
 *
 */
public class Feld {
	/**
	 * Bereich, zu dem dieses Feld gehört
	 */
	private Bereich parentBereich;
	
	/**
	 * Auflistung der Rohstoffe und deren Menge, die das Feld enthält
	 */
	private HashMap<BodenMaterial, Float> bodenschatzVorkommen;
	
	/**
	 * Material aus dem der Boden hier ist
	 */
	private BodenMaterial bodentyp;
	
	/**
	 * Platz, an dem ein Gebäude o.ä. errichtet werden kann
	 * Kann auch durch natürliche Objekte eingenommen werden
	 */
	private Platzierbar bauplatz;

	/**
	 * Zufalls Konstruktor
	 * 
	 * @param bereich Bereich, zu dem das Feld gehört
	 * @param bodenschaetze Mögliche bodenschatze
	 * @param bodentypen Mögliche Bodenarten
	 */
	Feld(Bereich bereich, ArrayList<BodenMaterial> bodenschaetze, ArrayList<BodenMaterial> bodentypen) {
		this.parentBereich = bereich;
		
		bodenschatzVorkommen = new HashMap<BodenMaterial, Float>();
		
		//rohstoffe generieren
		//Alle Bodenschaetze, die dem Feld in der ArrayList übergeben wurden
		Iterator<BodenMaterial> iterator = bodenschaetze.iterator();
		BodenMaterial temp;
		double random;
		while (iterator.hasNext()) {
			temp = iterator.next();
			
			//Vorkommenswahrscheinlichkeit mit einbringen
			random = Math.random();
			if (random <= temp.getVorkommensWkeit()) {
				setRohstoff(temp, (float)1); //1 entspricht 100%
				//TODO Menge einstellen
				/*
				 * idee:
				 * Menge doch Vorkommens W-keit
				 * wenn unter bestimmten schwellenwert, rauslassen. ANsonsten immer vorhanden
				 * in ermittelter Menge
				 */
			}
		}
		
		//bodenart generieren; sich für einen Boden entscheiden
		//für jede Art eine zahl aus zufall und vorkommensWkeit generieren
		//größte Zahl wird ausgewählt
		double[] genZahl = new double[bodentypen.size()];
		for (int i = 0; i < bodentypen.size(); i++) {
			random = parentBereich.getParentKarte().getPrng().random();
			genZahl[i] = bodentypen.get(i).getVorkommensWkeit() * random;
		}
		int largest = 0;
		for (int i = 0; i < genZahl.length; i++) {
			if (genZahl[largest] < genZahl[i]) {
				largest = i;
			}
		}
		bodentyp = bodentypen.get(largest);
	}
	
	/**
	 * Stellt die Menge des angegebenen Rohstoffs für das Feld ein
	 * Wenn ein vorheriger Wert für diesen Rohstoff existiert, wird er überschrieben
	 * 
	 * @param rohstoff Art des Rohstoffs
	 * @param menge Menge des Rostoffs
	 */
	public void setRohstoff(BodenMaterial rohstoff, Float menge) {
		bodenschatzVorkommen.put(rohstoff, menge);
	}

	/**
	 * @return the rohstoffe
	 */
	public HashMap<BodenMaterial, Float> getRohstoffe() {
		return bodenschatzVorkommen;
	}
	
	/**
	 * @return the bereich
	 */
	public Bereich getParentBereich() {
		return parentBereich;
	}

	/**
	 * 
	 * @return the bodenschatzVorkommen
	 */
	public HashMap<BodenMaterial, Float> getBodenschatzVorkommen() {
		return bodenschatzVorkommen;
	}

	/**
	 * @return the bodentyp
	 */
	public BodenMaterial getBodentyp() {
		return bodentyp;
	}

	/**
	 * @return the bauplatz
	 */
	public Platzierbar getBauplatz() {
		return bauplatz;
	}

	/**
	 * @param bauplatz the bauplatz to set
	 * TODO bedingungen für den Bau eines Objekts
	 */
	public void setBauplatz(Platzierbar bauplatz) {
		this.bauplatz = bauplatz;
	}
}
